# 分布式解决的问题：单点问题

**单点问题：**

若某服务器程序，只使用节点部署这个服务（只用一个物理服务器，来部署这个服务器程序），则会有以下问题

1. **可用性问题**：若这个机器挂了，则服务直接中断，也就是可用性较低。
2. **性能问题**：支持的并发量也是有限的。（根本原因是单个机器所能提供的各种硬件资源是有限的）

所以，引入分布式系统，就是为了解决上述单点问题。在分布式系统中，往往希望有多个服务器来部署redis服务，从而构成一个redis集群。此时就可以让这个redis集群给整个分布式的其他服务提供更稳定/更高效的数据存储功能~

具体来说，使用多个服务器部署redis服务有以下几个部署方式：

1. 主从模式
2. 主从+哨兵模式
3. 集群模式

> 在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他服务器，满⾜故障恢复和负载均衡等需求。Redis 也是如此，它为我们提供了复制的功能，实现了相同数据的多个 Redis 副本。**复制功能是高可用 Redis 的基础**，哨兵和集群都是在复制的基础上构建的。
>

# 主从模式说明

- 主从模式：若干个redis节点中，一个节点为主节点，其余节点为从节点。（使用一个物理服务器部署redis-server服务为一个节点）
- 主节点保存redis服务的数据，引入从节点时，需要复制主节点的数据给从节点。并且后续主节点上的数据有任何修改，就需要将这些数据修改同步给从节点。（从节点就是主节点的副本）
- Redis主从模式中，从节点只能读数据，不能写数据。写数据操作只能在主节点上。
- 可用性问题：主节点挂了，客户端的读操作可以继续发给其他从节点。读操作的可用性提高。
  并发量问题：因为从节点的数据是和主节点保持一致的，所以，客户端可以随意选择一个节点进行读操作。这里引入了更多的硬件资源，所以能够支持的读操作的并发量也就大幅提高了~

- **所以更准确的说，主从模式主要是针对读操作的可用性&并发量的提高。而写操作因为必须在主节点，主节点一旦挂了，写操作就无法继续执行，所以无论是写操作的可用性还是并发量都没有提高。（不过实际业务场景中，读操作往往比写操作更频繁(得多)**
- ![image-20230921115241841](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230921115241841.png)
  **如果某从节点挂了，没什么影响，因为读写操作都可以继续执行。如果主节点挂了，是有影响的，因为写操作无法继续执行，只能在从节点中进行读操作了。所以还是那句话，主从模式主要是读操作的可用性和并发量提高了。整体的可用性还没有达到非常理想的程度。**

# 主从复制/主从模式的配置

> 真正的分布式redis主从模式是将每个redis服务部署在一个单独的主机上，因为此处只有一个云服务器，所以，只能以多个redis服务绑定不同的端口的方式来模拟主从模式。如果有多个主机，绝大部分的配置方式也没什么不同，只是允许端口号重复而已。

## 建立复制

参与复制的 Redis 实例划分为主节点（master）和从节点（slave）。只能有⼀个主节点， ⽽⼀个主节点可以同时具有多个从结点。复制的数据流是单向的，只能由主节点到从节点。

> 拷贝两个redis配置文件，然后分别作为从节点1的配置文件和从节点2的配置文件。
>
> 创建两个目录，分别作为从节点1的工作目录和从节点2的工作目录（rdb文件和aof文件就存储在这里）
>
> 在配置文件中，主要做如下更改：（主节点的配置文件不需要更改）
>
> 1. 修改端口号，主节点为6379，从1可以定为6380，从2可以定为6381。
> 2. 修改工作目录为刚刚创建好的目录。
> 3. 设定daemonize yes，也就是以后台进程的方式运行

4. 最重要的：设定主从关系。有三种方式

   1. 在配置⽂件中加⼊ slaveof {masterHost} {masterPort} 随 Redis 启动⽣效。 

   2. 在 redis-server 启动命令时加⼊ --slaveof {masterHost} {masterPort} ⽣效。 
   3. 直接使⽤ redis 命令：slaveof {masterHost} {masterPort} ⽣效。（暂时性）

更推荐第一种，因为修改了配置文件，是持久生效的。

- 所以，这样的主从模式即为6379端口的redis-server为主节点，6380 6391为两个从节点。

- 每个从节点和主节点都会建立TCP连接，以供后期的数据同步。

- 无语，slaveof ip port，不要加{}，不然是错误的...~

![image-20230905133652439](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230905133652439.png)![image-20230905135004651](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230905135004651.png)

![image-20230905141242291](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230905141242291.png)

> 小tip：
>
> 1. 修改配置文件后，需要重启redis服务才能生效。
> 2. `redis-server /工作目录` 的redis服务启动方式和kill -9的终止方式配对。service redis-server start 和 service redis-server stop的终止方式配对。
>    如果第二种的启动使用kill -9终止，是会自动重启的。（主要是为了提高服务器程序的可用性与稳定性）

![image-20230905135407596](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230905135407596.png)

![image-20230905141347362](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230905141347362.png)

如上图，三个处于LISTEN状态的redis服务，下面三对TCP连接，分别是redis-cli和主节点建立的TCP连接；从节点1与主节点建立的TCP连接；从节点2与主节点建立的TCP连接；

```C++
[root@hecs-296309 yzl]# redis-cli -p 6380
127.0.0.1:6380> keys *
(empty list or set)
127.0.0.1:6380> keys *
1) "k1"
127.0.0.1:6380> get k1
"hhhhhhha"
127.0.0.1:6380> keys *
1) "k2"
2) "k1"
127.0.0.1:6380> set k3 vvvvvvvalue
(error) READONLY You can't write against a read only replica.
```

事实证明，从节点会自动同步主节点的数据，并且只能读，不能写。readonly

**可以通过 info replication 命令查看复制相关状态信息。**

```C++
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:2     // 两个从节点
slave0:ip=127.0.0.1,port=6380,state=online,offset=858,lag=0    // 从节点1相关信息，ip，port，状态，offset，lag
slave1:ip=127.0.0.1,port=6381,state=online,offset=858,lag=1    // 从节点2相关信息，ip，port，状态，offset，lag
master_replid:379f81b27e7237f5b7569ae0d47b6d7b3240054c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:858
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:858
    
127.0.0.1:6380> info replication
# Replication
role:slave                // 6380端口redis服务为从节点
master_host:127.0.0.1     // 主节点ip
master_port:6379		  // 主节点端口号
master_link_status:up
master_last_io_seconds_ago:6
master_sync_in_progress:0
slave_repl_offset:886
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:379f81b27e7237f5b7569ae0d47b6d7b3240054c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:886
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:886
```

**有关offset字段：标识的是主从节点之间数据同步的进度**：因为主节点会不断的修改数据，并且需要将数据的修改同步给从节点，但是这种数据同步并非总是非常及时的。于是用offset表示主从数据同步的情况。

offset的更多内容看下方的psync数据同步。

## 断开复制

slaveof 命令不但可以建⽴复制，还可以在从节点执⾏ `slaveof no one` 来断开与主节点复制关系。 例如在 6380 节点上执⾏ slaveof no one 来断开复制。

断开复制主要流程： 

1. 断开与主节点复制关系。 
2. 从节点晋升为主节点。

- 从节点执行slaveof no one，它不再是其他节点的从节点，使用info replication显示其为master角色。

- 现有的数据不会丢弃，不过当然后期之前主节点的数据修改也就不会同步给此节点了。

通过 slaveof 命令还可以实现切主操作（切换主节点操作），将当前从节点的数据源切换到另⼀个主节点。执⾏ slaveof {newMasterIp} {newMasterPort} 命令即可。 

切主操作主要流程： 

1. 断开与旧主节点复制关系。 

2. 与新主节点建⽴复制关系。 

3. 删除从节点当前所有数据。 

4. 从新主节点进⾏复制操作。

---

**安全性**

对于数据⽐较重要的节点，主节点会通过设置 requirepass 参数进⾏密码验证，这时所有的客户端访问必须使⽤ auth 命令实⾏校验。从节点与主节点的复制连接是通过⼀个特殊标识的客⼾端来完成，因此需要配置从节点的masterauth 参数与主节点密码保持⼀致，这样从节点才可以正确地连接到主节点并发起复制流程。

**只读**

默认情况下，从节点使⽤ slave-read-only=yes 配置为只读模式。由于复制只能从主节点到从节 点，对于从节点的任何修改主节点都⽆法感知，修改从节点会造成主从数据不⼀致。**所以不要修改从节点的只读模式。**

**传输延迟**

**主从节点⼀般部署在不同机器上，复制时的⽹络延迟就成为需要考虑的问题**，Redis 为我们提供 了 `repl-disable-tcp-nodelay` 参数⽤于控制是否关闭 TCP_NODELAY，默认为 no，即开启 TCP_NODELAY 功能（开启TCP低延迟功能）

- 当关闭时（开启低延迟），**主节点产⽣的命令数据⽆论大小都会及时地发送给从节点**，这样主从之间**延迟会变小**， 但**增加了网络带宽的消耗**。适用于主从之间的网络环境良好的场景，如同机房部署。
- 当开启时（关闭低延迟），**主节点会合并较⼩的 TCP 数据包**从⽽**节省带宽**。默认发送时间间隔取决于 Linux 的内核，⼀般默认为 40 毫秒。这种配置**节省了带宽但增⼤主从之间的延迟**。适⽤于主从⽹络环境复杂的场景，如跨机房部署。

# 主从复制/主从模式的拓扑结构

Redis 的复制拓扑结构（主从模式的拓扑结构）可以⽀持单层或多层复制关系

根据拓扑复杂性可以分为以下三种：⼀主⼀从、⼀主多从、树状主从结构。

## 一主一从

⼀主⼀从结构是最简单的复制拓扑结构，⽤于主节点出现宕机时从节点提供故障转移⽀持。

如图。当应⽤写命令并发量较⾼且需要持久化时，可以关闭主节点的AOF，只在从节点上开启 AOF，这样既可以保证数据安全性同时也避免了持久化对主节点的性能⼲扰。

但需要注意的是，当主节点关闭持久化功能时，如果主节点宕机要避免⾃动重启操作。（可以让主节点从从节点这里获取AOF文件，再重启~）

![image-20230905154816736](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230905154816736.png)

## 一主多从

⼀主多从结构（星形结构）使得应⽤端可以利⽤多个从节点实现**读写分离**

> 对于**读比重较大的场景**，可以把读命令负载均衡到不同的从节点上来分担压⼒。同时⼀些耗时的读命令可以指定⼀台专⻔的从节点执⾏，避免破坏整体的稳定性。

**对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送(同步)从⽽加重主节点的负载。**也就是一主多从结构中，主节点的数据同步压力比较大。

![image-20230905154920910](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230905154920910.png)

## 树状主从

**树形主从结构（分层结构）使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。**

通过引⼊复制中间层，**可以有效降低主节点的写操作需要传送给从节点的数据量**（对于一主多从的缺点的改进）

如图。数据写⼊节点 A 之后会同步给 B 和 C 节点，B 节点进⼀步把数据同步给 D 和 E 节 点。**当主节点需要挂载等多个从节点时为了避免多次数据同步对主节点的性能干扰，可以采用这种树状主从拓扑结构。**

但是这种结构的缺点是：数据同步的延时更长一些。

![image-20230905154927898](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230905154927898.png)

# 主从复制

## 主从复制的流程 - SLAVEOF

**主从服务器建立复制关系的流程**

slaveof 127.0.0.1 6378 可以是配置在在从redis服务器的配置文件中，可以是在从redis-server启动时通过命令行参数传递，可以是redis-cli的命令输入。总之，从节点redis服务器收到此命令后，会执行如下流程来与主节点建立复制关系。(Redis2.8版本及以上)

1. **从节点保存主节点的host和port**

   实际上就是保存在redisServer类的数据成员中的, <u>slaveof命令是一个异步命令</u>, 从服务器在保存IP+端口之后, 该从服务器就会向发送slaveof命令的客户端回复OK, 实际的复制工作在回复OK之后开始执行.

2. **从服务器与主服务器建立基于 TCP 的网络连接**

   从服务器视角: 将建立好的连接的套接字加入多路复用中进行监控, 用于接收后续主服务器发送来的RDB文件以及写命令.

   主服务器视角: 主服务器将从服务器看作一个客户端, 是因为复制工作的接下来的几个步骤都是以从服务器向主服务器发送命令请求的方式来进行, 所以在建立复制关系的过程中, 从服务器是主服务器的客户端.

3. **从服务器向主服务器发送PING命令**

   目的&作用: 1. 检查套接字的读写状态是否正常 2. 检查主服务器能否正常处理命令请求(因为接下来的几个步骤都是基于从服务器向主服务器发送命令的方式)

   分类情况: 1. 从服务器读取PING命令的回复超时, 则证明主从之间的网络连接状态不佳 2. 主服务器返回一个错误, 表示暂时无法处理从服务器的命令请求  则从服务器将断开连接, 并重新创建连向主服务器的套接字  3. 从服务器读取到PONG回复, 则表示主服务器可以正常处理请求, 则继续接下来的步骤.

4. **身份验证 / 权限验证**

   是否进行身份验证取决于从服务器是否设置了masterauth选项  ...

5. **从服务器向主服务器发送自己的监听端口号**

   方式依旧是命令请求: `replconf listening-port xxx`, 主服务器收到该命令之后, 就会将端口号保存在主服务器进程中的redisClient结构中slave_listening_port数据字段中

   作用&目的: 主服务器执行`info replication`命令时打印出从服务器的端口号

6. **同步数据集**

   从服务器向主服务器发送`PSYNC`命令, 执行同步操作

   在次之前, 从服务器是主服务器的客户端, 但在此之后, 主服务器也会成为从服务器的客户端. 原因: 不管是全量复制还是部分复制, 又或者是后续的实时复制(下一点), 都需要主服务器向从服务器发送写命令从而改变从服务器的状态

   具体同步数据集又分为全量复制与部分复制, 这里也是主从复制的核心

   <u>redis 2.8之前的SYNC命令没有部分复制，只有全量复制，而因为全量复制太耗时，不适合于主从之间短时间的断线重连的场景，所以redis 2.8之后的PSYNC引入了部分复制。</u>

7. **命令持续传播(实时复制)**

   完成主从同步之后, 主服务器就会进入命令传播阶段, 也就是主服务器持续将自己执行的写命令发送给从服务器(主也是从的客户端), 从服务器执行主服务器发送来的写命令即可保证主从状态一致

> 67是重点。6又分为全量复制和部分复制。其实也就是主从复制的核心。而7就是实时复制。

## 主从数据同步 - PSYNC

**PSYNC命令执行流程**

<img src="C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230905161218264.png" alt="image-20230905161218264" style="zoom: 67%;" />

- 若从服务器是第一次与主服务器建立复制, 则会发送`PSYNC ? -1`命令, 意图是进行全量同步, 此时也只能全量同步
- 若从服务器之前与主服务器建立过复制关系, 比如主从节点短时间的短线重连场景, 则从会向主发送`PSYNC replid offset`, 意图是想进行部分复制, 此时主服务器接收到这个命令之后会根据两个参数来决定具体执行哪种复制操作.

接收到PSYNC命令的主服务器会向从服务器回复以下三种中的一种:

- +FULLRESYNC replid offset，则表示主服务器将与从服务器进行**全量复制.**

  此时从服务器可以将replid offset保存起来, 下次进行数据同步时, 可以以上方第二种情况那种尝试进行部分复制

- +CONTINUE，主从将进行**部分复制**

- -ERR, 表示主服务器版本低于Redis 2.8, 无法处理PSYNC命令, 则从服务器会向主服务器发送SYNC, 进行全量复制.

### 全量复制

#### 全量复制的过程

Redis2.8之后的PSYNC命令支持全量复制, Redis2.8之前的SYNC命令只支持全量复制, 这也是主从节点首次建立复制时, 进行主从数据同步所必须进行的

![image-20230919210214214](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230919210214214.png)

> 此处的全量复制其实是SLAVEOF命令的一个子流程, 也就是上方所示的第六点 - 同步数据集, 核心命令是PSYNC命令

第一阶段: 

从节点发送 PSYNC 命令给主节点, 主节点回复 +FULLRESYNC replid offset, 从节点保存主节点的replid offset（开始全量复制）

第二阶段: 

主节点执⾏ bgsave 生成一个RDB文件, 同时用一个缓冲区记录现在开始执行的写命令, BGSAVE 执行结束, 将这个RDB文件发送给从节点, 从节点接收并载入这个RDB文件, 此时, 从节点的数据库状态同步至主节点执行BGSAVE命令时的状态

第三阶段:

主节点将缓冲区记录的写命令发送给从节点, 从节点执行接收到的写命令, 此时, 从节点的数据库状态同步至主节点当前所处的状态.

> 如果从节点开启了 AOF 持久化功能。则从节点执行完上方过程之后，它会进⾏ `bgrewriteaof` 操作，也就是重写一下aof文件，因为可能刚才的耗时是比较长的。

#### 全量复制的缺陷

通过分析全量复制的所有流程，我们会发现**全量复制是⼀个非常耗费资源的操作**

1. 主服务器BGSAVE生成RDB文件, 消耗主服务器大量的CPU, 内存, 磁盘IO资源
2. 主服务器发送RDB文件给从服务器, 耗费主从服务器大量的网络带宽&流量资源, 且也会影响主服务器响应命令请求(尽管生成RDB文件是以创建子进程的方式进行的, 但是这里依旧会影响)
3. 从服务器接收到RDB文件之后, 载入RDB文件时也会阻塞从服务器, 从而无法处理命令请求.

正是因为全量复制是一个非常耗费资源的操作, 所以, 除了主从服务器第一次建立复制关系时必须进行全量复制的场景, 其它的, 比如主从节点因为网络原因短时间中断了复制, 后续重新建立了连接, 此时如果要想进行主从数据同步, 若进行全量复制就太不值当了, 因为从节点只需要补足一小部分连接中断期间缺失的数据, 而此时, 就是适合部分复制的场景. (Redis2.8之后的PSYNC相比于2.8之前的SYNC命令的优化, 就是支持了部分复制)

> 有磁盘复制 vs ⽆磁盘复制(diskless)
>
> 默认情况下, 进⾏全量复制需要主节点⽣成 RDB ⽂件到主节点的磁盘中, 再把磁盘上的 RDB ⽂件发送给从节点. 
>
> Redis 从 2.8.18 版本开始⽀持⽆磁盘复制. 主节点在执⾏ RDB ⽣成流程时, 不会⽣成 RDB ⽂件到磁盘中了, ⽽是直接把⽣成的 RDB 数据通过⽹络发送给从节点. 这样就节省了⼀系列的写硬盘和读硬盘的操作开销.

### 部分复制

#### 复制偏移量offset

- 参与复制的主从节点都会维护自身的复制偏移量。
- 主服务器每次向从服务器传播N字节数据之后, 就会将自己的复制偏移量加上N
- 从服务器接收到主服务器传播来的N字节数据时, 就会将自己的复制偏移量加上N

```cpp
127.0.0.1:6380> info replication
# Replication
role:slave                // 6380端口redis服务为从节点
...
slave_repl_offset:886
...
```

- 并且从节点（slave）还会每秒钟上报⾃⾝的复制偏移量offset给主节点，因此主节点也会保存从节点的复制偏移量。
- 复制偏移量的维护如图所⽰。**通过对比主从节点的复制偏移量，可以判断主从节点数据是否⼀致/数据同步进度。**

<img src="C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230905160942417.png" alt="image-20230905160942417" style="zoom:80%;" />

- replid + offset 共同标识了⼀个 "数据集". 如果两个节点, 他们的 replid 和 offset 都相同, 则这两个节点上持有的数据, 就⼀定相同.

#### 复制积压缓冲区

复制积压缓冲区（repl-backlog-buffer）是保存在主服务器上的⼀个固定⻓度的, 先进先出的队列，默认⼤⼩为 1MB

- 在主节点进行命令传播时, 不仅会将写命令发送给所有的从服务器, 还会将写命令保存在复制积压缓冲区中
- 因为复制积压缓冲区是一个队列结构, 所以里面会保存一部分最近传播的写命令
- 当从节点断线重连主节点, 发送PSYNC replid offset之后, 主节点会根据这个复制偏移量offset来决定进行何种同步
  - 若offset+1开始的数据仍然在复制积压缓冲区中, 则回复+CONTINUE，主从将进行**部分复制**
  - 若offset偏移量之后的数据已经不存在于复制积压缓冲区中, 则回复+FULLRESYNC replid offset. 即**全量复制.**

![image-20230905162656672](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230905162656672.png)

> 复制积压缓冲区的默认大小为1MB, 这个不是固定的, 可通过配置文件进行配置, 复制积压缓冲区最小的大小应当为 second * write_size_per_second, 安全起见, 可以将复制积压缓冲区的大小设为 2 * second * write_size_per_second
>
> second为从服务器断线重连主服务器所需要的 平均时间
>
> write_size_per_second为主服务器每秒产生的写命令的 平均数据量(带Redis的应用层协议)

```C++
127.0.0.1:6379> info replication
# Replication
role:master
...
repl_backlog_active:1             // 开启复制缓冲区
repl_backlog_size:1048576		  // 缓冲区最⼤⻓度
repl_backlog_first_byte_offset:1  // 起始偏移量，计算当前缓冲区可⽤范围
repl_backlog_histlen:858          // 已保存数据的有效⻓度
```

#### replicationid(replid-复制id)

主节点重新启动, 或者从节点晋级成主节点, 都会⽣成⼀个 replicationid. (同⼀个节点, 每次重启, ⽣成的 replicationid 也会变化). 从节点在和主节点建⽴连接之后, 就会获取并保存主节点的 replicationid.

主节点接收到从节点的PSYNC replid offset之后, 根据replid即可判断该从节点在此次连接之前连接的主节点是否是自己, 若是, 则可能进行部分重同步, 若不是, 则全量重同步

通过 info replication 即可看到 replicationid

```cpp
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:2     // 两个从节点
slave0:ip=127.0.0.1,port=6380,state=online,offset=858,lag=0    // 从节点1相关信息，ip，port，状态，offset，lag
slave1:ip=127.0.0.1,port=6381,state=online,offset=858,lag=1    // 从节点2相关信息，ip，port，状态，offset，lag
master_replid:379f81b27e7237f5b7569ae0d47b6d7b3240054c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:858    // offset
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:858
```

> 关于 `master_replid` 和 `master_replid2`
>
> 每个节点需要记录两组 master_replid . 这个设定解决的问题场景是这样的: 
>
> ⽐如当前有两个节点 A 和 B, A 为 master, B 为 slave. 此时 B 就会记录 A 的 master_replid. 如果⽹络出现抖动, B 以为 A 挂了, B ⾃⼰就会成为主节点. 于是 B 给⾃⼰分配了新的 master_replid. 此时就会使⽤ master_replid2 来保存之前 A 的 master_replid. 后续如果⽹络恢复了, B 就可以根据 master_replid2 找回之前的主节点. 后续如果⽹络没有恢复, B 就按照自己的新的 master_replid ⾃成⼀派, 继续处理后续的数据.

其实知道了上面的三个前置知识, 部分复制如何进行也就比较清楚了

#### 部分复制的过程

PSYNC命令的部分重同步/部分复制功能, 解决了旧版SYNC复制功能在处理断线后重复制时出现的低效情况

![image-20230905162402066](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230905162402066.png)

1. 主从节点之间出现⽹络中断
2. 主从连接中断期间主节点依然响应命令，但这些写命令都因⽹络中断⽆法及时发送给从节点，同时, 主服务器会将这些命令入队列在复制积压缓冲区中（repl-backlog-buffer）
3. 当主从节点⽹络恢复后，从节点再次连上主节点。
4. 从节点将之前保存的 replicationId 和 复制偏移量offset 作为 psync 的参数发送给主节点，意图也就是请求进行部分复制。
5. 主节点收到PSYNC请求后, 校验replid与自己的replid是否一致, offset之后的偏移量的数据是否在复制积压缓冲区中, 若两个条件都符合, 则回复+CONTINUE，主从将进行部分复制
6. 主服务器会将复制积压缓冲区中offset偏移量之后的数据(offset+1)发送给从服务器

主从服务器即可以远低于全量复制成本的代价, 完成数据同步, 恢复主从数据一致性

### 实时复制

在同步数据集操作完成后, 主从数据库状态一致, 但是主节点后续会不断执行写命令, 即破坏主从一致性

**为了保证主从服务器的持续一致性, 主服务器会将自己执行的写命令, 发送给从服务器执行** (所以此时主服务器对于从服务器来说就是客户端的身份了, 这就是上方所说的在PSYNC命令执行之后, 也就是主从复制的第六步之后, 主服务器也会充当从服务器的客户端的角色)

> 实时复制的命令传播肯定也是需要时间的, 具有一定延迟, 而具体的一致性的延时还和拓扑结构有关，若一主多从结构则延迟相对低点，但是主节点的压力较大。树状结构延迟相对高点, 对应的, 也就减轻了主节点的命令传播压力。

## 心跳检测

> 此处的心跳检测是应用层主从服务器以周期性命令传输的形式进行的, 而不是传输层TCP的心跳包

在命令传播(实时复制)阶段, 从服务器默认会以每秒一次的频率, 向主服务器发送 `REPLCONF ACK replication_offset` 命令, 其中replication_offset就是复制偏移量offset

作用&目的

1. **检测主从服务器的网络连接状态**

   通过每秒一次的频率, 从服务器向主服务器发送replconf ack offset命令, 这样如果主服务器超过一秒钟没有接收到从服务器的此命令, 则主服务器就会及时察觉到主从之间的连接出问题了.

   `info replication` 命令显示的lag一项, 就是主从之间距离上次从向主发送 `replconf ack offset` 命令的时间, 正常情况下, lag一栏都不应该超过1

   ```C++
   127.0.0.1:6379> info replication
   # Replication
   role:master
   connected_slaves:2     // 两个从节点
   slave0:ip=127.0.0.1,port=6380,state=online,offset=858,lag=0    // 从节点1相关信息，ip，port，状态，offset，lag
   slave1:ip=127.0.0.1,port=6381,state=online,offset=858,lag=1    // 从节点2相关信息，ip，port，状态，offset，lag
   // ...
   ```

2. **辅助实现min-slaves选项**

   Redis的`min-slaves-to-write`和`min-slaves-max-lag`可以防止主服务器在不安全的情况下执行写命令

   `min-slaves-to-write` 和 `min-slaves-max-lag` 是 Redis 配置参数，用于控制 Redis 主从复制的行为。Redis 是一个开源的内存数据库，支持主从复制来提高数据的可用性和容错性。

   1. `min-slaves-to-write`：
      - 默认值：0
      - 该配置项定义了在进行写操作（例如SET、DEL等）时，至少需要多少个从节点（Slaves）处于可用状态才能执行写操作。如果配置为0，表示不需要等待从节点就可以进行写操作。
      - 通常情况下，设置一个大于0的值有助于确保数据的可用性和一致性。如果没有足够多的从节点处于可用状态，写操作可能会被拒绝或延迟执行，以防止数据丢失或不一致。
   2. `min-slaves-max-lag`：
      - 默认值：10
      - 该配置项定义了允许从节点与主节点之间的复制延迟（lag）的最大值。如果从节点的复制延迟超过了这个值，那么主节点会拒绝新的写请求，以确保数据的一致性。
      - 通常情况下，设置一个适当的 `min-slaves-max-lag` 值有助于防止从节点因为延迟较大而无法提供最新的数据。

   这两个配置项主要用于控制主从复制的可用性和数据一致性。通过适当地配置这些参数，可以确保 Redis 集群在面对故障时能够维持数据的一致性，并在正常情况下提供高可用性。根据实际需求，你可以根据集群的规模和性能要求来调整这些参数的值。

3. **检测命令丢失**

   考虑一种情况: 主服务器传播给从服务器的命令因为网络故障在传播图中丢失, 则对应的, 从服务器的offset就会小于主服务器的offset, 差值也就是该命令的长度, 而从服务器以每秒一次的频率发送命令给主服务器, 上报自己的offset, 主服务器就会察觉到命令丢失, 此时主服务器就会将复制积压缓冲区中[slaves_offset+1, matser_offset]区间的数据发送给从服务器, 从服务器执行对应的命令即可将自己的状态更新至主服务器当前所处的状态.

   因此, 复制积压缓冲区的作用并非只是解决主从断线重连之后部分复制的问题, 还可以解决命令丢失的问题. 这两者的差别仅仅在于, 补发缺失数据是在主从服务器没有断线的情况下执行, 而部分重同步操作是在主从服务器断线重连之后执行

   > PSYNC, 复制积压缓冲区, REPLCONF ACK命令 都是Redis2.8之后新增的, 而在2.8之前, 诸如此类的命令在传播过程中丢失的情况, 主服务器和从服务器都不会察觉到, 主服务器更不会补发丢失的数据, 所以为了保证主从复制时主从服务器的数据一致性, 最好使用2.8及以上版本的Redis

# 总结

- Redis 2.8以前的SYNC所支持的全量复制功能不能高效地处理主从服务器短时间断线后重复制情况，但Redis 2.8新添加的PSYNC的部分重同步功能可以解决这个问题。
- 部分重同步通过复制偏移量offset、复制积压缓冲区、replid三个部分来实现。
- 在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤, 而在复制操作的后期, 主从服务器会互相成为对方的客户端。
- 主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致, 而从服务器则通过周期性(每秒一次)向主服务器发送`REPLCONF ACK`命令的方式来进行心跳检测, 以及命令丢失检测。

主从复制的缺点:

- 从机多了, 复制数据的延时⾮常明显.
- 主机挂了, 从机不会升级成主机. 只能通过⼈⼯⼲预的⽅式恢复.  (引出sentinel哨兵机制)

