Redis是用C语言开发的, 但是Redis的字符串并非 C 语言传统的字符串, 而是自己构建的一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型. 在Redis中, C字符串只会用于一些需要字符串常量的地方, 即不会对字符串进行修改的地方.

Redis的SDS - 简单动态字符串的应用是非常广的

- Redis存储的每一个键值对的键都是一个SDS, 即字符串类型对象
- Redis的值虽然支持多种类型, 如哈希, 列表, 集合, 有序集合, 当然还有字符串等, 但是实际上很多值类型存储的基本对象类型依旧是SDS

- SDS 还被用作缓冲区（buffer）： AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区， 都是由 SDS 实现的

> 第二点举例: 
>
> 如果客户端执行命令：
>
> ```
> redis> RPUSH fruits "apple" "banana" "cherry"
> (integer) 3
> ```
>
> 那么 Redis 将在数据库中创建一个新的键值对， 其中：
>
> - 键值对的键是一个字符串对象， 对象的底层实现是一个保存了字符串 `"fruits"` 的 SDS 。
> - 键值对的值是一个列表对象， 列表对象包含了三个字符串对象， 这三个字符串对象分别由三个 SDS 实现： 第一个 SDS 保存着字符串 `"apple"` ， 第二个 SDS 保存着字符串 `"banana"` ， 第三个 SDS 保存着字符串 `"cherry"` 。

# SDS的定义

每个 `sds.h/sdshdr` 结构表示一个 SDS 值

```C
struct sdshdr {

    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 所保存字符串的长度
    int len;

    // 记录 buf 数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    char buf[];

};
```

说明: SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 `1` 字节空间不计算在 SDS 的 `len` 属性里面， 并且为空字符分配额外的 `1` 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。

因此, SDS中, len+free+1等于buf实际所占字节数

> SDS示例:
>
> ![image-20230926181350484](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230926181350484.png)
>
> - SDS 保存了字符串值 `"Redis"` 。
> - SDS 为 `buf` 数组分配了五字节未使用空间， 所以它的 `free` 属性的值为 `5`

# 对比SDS与C字符串

根据传统， C 语言使用长度为 `N+1` 的字符数组来表示长度为 `N` 的字符串， 并且字符数组的最后一个元素总是空字符 `'\0'` 。

而Redis使用了SDS这种简单动态字符串, 就是因为C字符串在安全性、效率、以及功能方面有一定的缺点/劣势, SDS就是对此的优化

## 1. 常数时间获取字符串长度

C字符串不记录字符串长度, 因为为了获取C字符串长度, 需要遍历字符串, 直到遇到'\0'截止, 这个操作的复杂度为O(N)

而SDS的len属性记录了SDS的字符串长度, 所以获取字符串长度的时间复杂度为O(1)

设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的， 使用 SDS 无须进行任何手动计算/修改长度的工作。

例如: 因为字符串键底层采用SDS实现, 因此即使是一个非常长的字符串键, 反复进行STRLEN命令, 也不会对系统性能造成任何影响, 因为获取字符串长度的时间复杂度为O(1)

## 2. 杜绝缓冲区溢出问题

除了获取字符串长度的复杂度高之外， C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。

举个例子， `<string.h>/strcat` 函数可以将 `src` 字符串中的内容拼接到 `dest` 字符串的末尾：

`char *strcat(char *dest, const char *src);`

因为C字符串没有记录自身长度, 所以strcat假定用户在执行时, 已经为 `dest` 分配了足够多的内存， 可以容纳 `src` 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。

与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。

> 举例:  SDS 的 API 里面也有一个用于执行拼接操作的 `sdscat` 函数， 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面， 但是在执行拼接操作之前， `sdscat` 会先检查给定 SDS 的空间是否足够， 如果不够的话， `sdscat` 就会先扩展 SDS 的空间， 然后才执行拼接操作。

## 3. 减少修改字符串时带来的内存重分配次数

因为C字符串没有记录自身长度, 且C字符串的长度和存储字符串的底层数组的长度存在固定的关系, 即数组长度 = 字符串长度+1. 导致每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作

- 若增长字符串, 比如拼接操作（append）, 则在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。
- 若缩短字符串, 比如截断操作（trim）, 则执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。

因为内存重分配涉及复杂的算法， 并且可能需要执行系统调用， 所以它通常是一个比较耗时的操作:

在一般程序中， 如果修改字符串长度的频率不高， 那么每次修改都执行一次内存重分配是可以接受的。但是 Redis 作为数据库， 经常被用于速度要求严苛、数据被频繁修改的场合， 如果每次修改字符串的长度都需要执行一次内存重分配的话， 那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分， 如果这种修改频繁地发生的话， 可能还会对性能造成影响。

为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， `buf` 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 `free` 属性记录。

通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。

### 空间预分配

**空间预分配用于优化 SDS 的字符串增长操作**： 当 SDS 的 API 需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会<u>为 SDS 分配额外的未使用空间。</u>

> 在扩展 SDS 空间之前， SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配。若不足, 则需要扩容
>
> 具体的额外空间计算公式:
>
> - 如果对 SDS 进行修改之后， SDS 的长度（也即是 `len` 属性的值）将小于 `1 MB` ， 那么程序分配和 `len` 属性同样大小的未使用空间， 这时 SDS `len` 属性的值将和 `free` 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `13` 字节， 那么程序也会分配 `13` 字节的未使用空间， SDS 的 `buf` 数组的实际长度将变成 `13 + 13 + 1 = 27` 字节（额外的一字节用于保存空字符）。
> - 如果对 SDS 进行修改之后， SDS 的长度将大于等于 `1 MB` ， 那么程序会分配 `1 MB` 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `30 MB` ， 那么程序会分配 `1 MB` 的未使用空间， SDS 的 `buf` 数组的实际长度将为 `30 MB + 1 MB + 1 byte` 。

**通过空间预分配策略， Redis 可以减少连续执行字符串增长操作所需的内存重分配次数。**

通过这种预分配策略， SDS 将连续增长 `N` 次字符串所需的内存重分配次数从C字符串的固定 `N` 次降低为最多 `N` 次。

### 惰性空间释放

惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 `free` 属性将这些字节的数量记录起来， 并等待将来使用。

> 举例:
>
> `sdstrim` 函数接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。
>
> 比如对于下图所示的 SDS 值 `s` 来说， 执行：
>
> ```C
> sdstrim(s, "XY");   // 移除 SDS 字符串中的所有 'X' 和 'Y'
> ```
>
> <img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230926190152162.png" alt="image-20230926190152162" style="zoom:67%;" />
>
> <img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230926190334164.png" alt="image-20230926190334164" style="zoom:67%;" />
>
> 注意执行 `sdstrim` 之后的 SDS 并没有释放多出来的 `8` 字节空间， 而是将这 `8` 字节空间作为未使用空间保留在了 SDS 里面， 如果将来要对 SDS 进行增长操作的话， 这些未使用空间就可能会派上用场。

**通过惰性空间释放策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。**

与此同时， SDS 也提供了相应的 API ， 让我们可以在有需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。

## 4. 二进制安全

C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符, 否则会读取到字符串的错误结尾 -- <u>这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</u>

虽然数据库一般用于保存文本数据， 但使用数据库来保存二进制数据的场景也不少见， 因此， 为了确保 Redis 可以适用于各种不同的使用场景， SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 `buf` 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。

这也是我们将 SDS 的 `buf` 属性称为字节数组的原因 —— **Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。**

也因此, SDS可以存储包含'\0'字符的字符串数据, 因为SDS是使用len属性而不是'\0'来判断字符串是否结束

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230926190756757.png" alt="image-20230926190756757" style="zoom:67%;" />

**通过使用二进制安全的 SDS ， 而不是 C 字符串， 使得 Redis 不仅可以保存文本数据， 还可以保存任意格式的二进制数据。**

## 5. 兼容部分C字符串函数

为什么Redis的SDS API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 `buf` 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些<u>保存文本数据的 SDS</u> 可以重用一部分 `<string.h>` 库定义的函数。(若保存的是图片, 视频等二进制数据就不能重用了~)

> ```C
> strcasecmp(sds->buf, "hello world");
> // 这样 Redis 就不用自己专门去写一个函数来对比 SDS 值和 C 字符串值了。
> strcat(c_string, sds->buf);
> // 这样 Redis 就不用专门编写一个将 SDS 字符串追加到 C 字符串之后的函数了。
> ```

C字符串 vs SDS

| C 字符串                                             | SDS                                                          |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| 获取字符串长度的复杂度为 O(N) 。                     | 获取字符串长度的复杂度为 O(1) 。                             |
| API 是不安全的，可能会造成缓冲区溢出。               | API 是安全的，不会造成缓冲区溢出。                           |
| 修改字符串长度 `N` 次必然需要执行 `N` 次内存重分配。 | 修改字符串长度 `N` 次最多需要执行 `N` 次内存重分配。(包含增长与缩短) |
| 只能保存文本数据。                                   | 可以保存文本或者二进制数据。                                 |
| 可以使用所有 `<string.h>` 库中的函数。               | 可以使用一部分 `<string.h>` 库中的函数。                     |
